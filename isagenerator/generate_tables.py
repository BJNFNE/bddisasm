#!/usr/bin/env python3
#
# Copyright (c) 2025 Bitdefender
# SPDX-License-Identifier: Apache-2.0
#
import os
import sys
import glob

from isg_x86.common import *
from isg_x86 import disasmlib
from isg_x86 import instrux
from isg_x86 import operand
from isg_x86 import decorators
from isg_x86 import cpuid
from isg_x86 import cpu_modes
from isg_x86 import instrux_grouper


header = '''/*
 * Copyright (c) 2025 Bitdefender
 * SPDX-License-Identifier: Apache-2.0
 */

//
// This file was auto-generated by generate_tables.py. DO NOT MODIFY!
//

'''

# Set this to True to generate the instructions database with designated initializers format:
#   ".FieldName = Value"
# Set this to False to generate the instructions database with aggregate initializers format:
#   "/* FieldName */ Value"
# Designated initializers can be used when building as C code (recommended!) or C++ >= 20.
# Aggregate initializers must be used when building as C++ code (NOT recommended).
idbe_format_designated = True

mnemonics       = []
instructions    = []
features        = []


def instrux_to_idbe(
    ins: instrux.Instruction
) -> dict:
    """ 
    Generates a dictionary equivalent to the ND_IDBE structure. Each dictionary key is equivalent 
    to a ND_IDBE structure field. Restrictions:
    - The order of the keys must be identical to the order of fields inside ND_IDBE
    - There must be no gaps; if a field is not used, just initialize it to some default value
    - The names must be identical to field names inside ND_IDBE

    Parameters
    ----------
    ins: instrux.Instruction
        The instruction to be converted to a dictionary.

    Returns
    -------
    A dictionary representing the bddisasm C definition of this instrux.
    """
    d = {}

    # Basic information.
    d['Instruction'] = f'ND_INS_{ins.Class}'                # Instruction class
    d['Category'] = f'ND_CAT_{ins.Category}'                # Instruction Category
    d['IsaSet'] = f'ND_SET_{ins.Set}'                       # ISA Set
    d['Mnemonic'] = f'{(mnemonics.index(ins.Mnemonic))}'    # Mnemonic (index)

    # Accepted prefixes map
    if ins.Prefmap.Names:
        d['ValidPrefixes'] = '|'.join([f'ND_PREF_{x.upper()}' for x in ins.Prefmap.Names])
    else:
        d['ValidPrefixes'] = '0'

    # Valid modes
    if not ins.Modes.contains_all_modes():
        d['ValidModes']  = '|'.join([f'ND_MOD_{m.upper()}' for m in ins.Modes.Names])
    else:
        d['ValidModes'] = 'ND_MOD_ANY'

    # Valid decorators
    if ins.Decorators.Names:
        d['ValidDecorators'] = '|'.join([f'ND_DECO_{x.upper()}' for x in ins.Decorators.Names])
    else:
        d['ValidDecorators'] = 0

    # Operand count
    d['OpsCount'] = f'ND_OPS_CNT({len(ins.ExpOps)}, {len(ins.ImpOps)})'

    # EVEX tuple type
    if ins.Tuple.Name:
        d['TupleType'] = f'ND_TUPLE_{ins.Tuple.Name.upper()}'
    else:
        d['TupleType'] = '0'

    # Exception type
    if ins.ExType.Name:
        d['ExcType'] = f'ND_EXT_{ins.ExType.Name}'
    else:
        d['ExcType'] = '0'

    # FpuFlags (x87 instructions only)
    if ins.Set == 'X87' and ins.FpuFlags.Names:
        value = 0
        acc = { '0': 0, '1': 1, 'm': 2, 'u': 3 }
        for i in range(0, 4):
            value |= acc[ins.FpuFlags.Names[i]] << (i * 2)
        d['FpuFlags'] = f'0x{value:02x}'
    elif ins.Set == 'X87':
        d['FpuFlags'] = '0xff' # All undefined.
    else:
        d['FpuFlags'] = '0'

    # EVEX mode
    if ins.EvexMode.Name:
        d['EvexMode'] = f'ND_EVEXM_{ins.EvexMode.Name.upper()}'
    else:
        d['EvexMode'] = '0'

    # SIMD Floating-Point Exceptions.
    if ins.SimdExc.Names:
        d['SimdExc'] = '|'.join([f'ND_SIMD_EXC_{x}' for x in ins.SimdExc.Names])
    else:
        d['SimdExc'] = '0'

    # Instruction payload bytes.
    d['Ipb'] = f'ND_IPB_{ins.Ipb}' if ins.Ipb else '0'

    # Pre-decoded access info.
    d['CsAccess']   = '|'.join([f'ND_OPA_{x}' for x in ins.CsAccess  ]) or '0'
    d['RipAccess']  = '|'.join([f'ND_OPA_{x}' for x in ins.RipAccess ]) or '0'
    d['RflAccess']  = '|'.join([f'ND_OPA_{x}' for x in ins.RflAccess ]) or '0'
    d['Mem1Access'] = '|'.join([f'ND_OPA_{x}' for x in ins.Mem1Access]) or '0'
    d['Mem2Access'] = '|'.join([f'ND_OPA_{x}' for x in ins.Mem2Access]) or '0'
    d['StkAccess']  = '|'.join([f'ND_OPA_{x}' for x in ins.StkAccess ]) or '0'
    d['StkWords']   = ins.StkWords

    # Flags (tested, modified, set, cleared)
    for m in ['t', 'm', '1', '0']:
        flg = '0'
        dst = ins.Rflags.Names[m]
        if m == '1' or m == '0':
            dst = dst + ins.Rflags.Names['u']
        for f in dst:
            flg += f'|NDR_RFLAG_{f.upper()}'
        if m == 't': d['TestedFlags'] = flg
        if m == 'm': d['ModifiedFlags'] = flg
        if m == '1': d['SetFlags'] = flg
        if m == '0': d['ClearedFlags'] = flg

    # Instruction attributes
    if a := ins.Attributes.instruction_attributes():
        d['Attributes'] = '|'.join([f'ND_FLAG_{x.upper()}' for x in a])
    else:
        d['Attributes'] = '0'

    # CPUID flag
    flg = '0'
    for feat in features:
        if feat.Name == ins.Id:
            flg = f'ND_CFF_{feat.Name}'
    d['CpuidFlag'] = flg

    # List of instruction operands
    d['Operands'] = []
    for op in ins.ExpOps + ins.ImpOps:
        d['Operands'].append(cdef_operand(op))

    return d

def cdef_operand(
    op: operand.Operand
) -> str:
    """ 
    Generates a bddisasm C definition for the current operand.

    Parameters
    ----------
    op: Operand
        The operand to be converted in a C definition.

    Returns
    -------
    A string representing the bddisasm C definition of this operand.

    Example
    -------
    "OP(ND_OPT_M, ND_OPS_y, 0, ND_OPA_RW, 0, 0)"
    """
    return 'OP(%s, %s, %s, %s, %s, %d)' % (
            'ND_OPT_' + op.Type,
            'ND_OPS_' + (op.Size if op.Size != '?' else 'unknown'),
            '|'.join(['ND_OPF_' + x for x in op.Flags]) or '0',
            'ND_OPA_' + op.Access,
            '|'.join(['ND_OPD_' + decorators.deco_op_flags[x] for x in op.Decorators]) or 0,
            op.Block)

def cdef_instruction(
    ins: instrux.Instruction
) -> str:
    """
    Generates a bddisasm C or CPP definition for the current instruction.
    If C style definition is used, designated initializers are used.
    If CPP definition is required, aggregate initialization is used.

    Parameters
    ----------
    ins: Instruction
        The instruction to be converted in a C structure.

    Returns
    -------
    A multi-line string representing the bddisasm C or CPP definition of this instruction.

    Example
    -------
    Designated initializer definition:
    // Pos:3 Instruction:"AADD My,Gy" Encoding:"NP 0x0F 0x38 0xFC /r:mem"/"MR"
    {
        .Instruction = ND_INS_AADD,
        .Category = ND_CAT_RAOINT,
        .IsaSet = ND_SET_RAOINT,
        .Mnemonic = 2,
        .ValidPrefixes = 0,
        .ValidModes = ND_MOD_ANY,
        .ValidDecorators = 0,
        .OpsCount = ND_OPS_CNT(2, 0),
        .TupleType = 0,
        .ExcType = 0,
        .FpuFlags = 0,
        .EvexMode = 0,
        .SimdExc = 0,
        .TestedFlags = 0,
        .ModifiedFlags = 0,
        .SetFlags = 0,
        .ClearedFlags = 0,
        .Attributes = ND_FLAG_NOREX2|ND_FLAG_MODRM,
        .CpuidFlag = ND_CFF_RAOINT,
        .Operands = 
        {
            OP(ND_OPT_M, ND_OPS_y, 0, ND_OPA_RW, 0, 0),
            OP(ND_OPT_G, ND_OPS_y, 0, ND_OPA_R, 0, 0),
        },
    }, 

    Aggregate initializer definition:
    // Pos:3 Instruction:"AADD My,Gy" Encoding:"NP 0x0F 0x38 0xFC /r:mem"/"MR"
    {
        /*      Instruction */ ND_INS_AADD,
        /*         Category */ ND_CAT_RAOINT,
        /*           IsaSet */ ND_SET_RAOINT,
        /*         Mnemonic */ 2,
        /*    ValidPrefixes */ 0,
        /*       ValidModes */ ND_MOD_ANY,
        /*  ValidDecorators */ 0,
        /*         OpsCount */ ND_OPS_CNT(2, 0),
        /*        TupleType */ 0,
        /*          ExcType */ 0,
        /*         FpuFlags */ 0,
        /*         EvexMode */ 0,
        /*          SimdExc */ 0,
        /*      TestedFlags */ 0,
        /*    ModifiedFlags */ 0,
        /*         SetFlags */ 0,
        /*     ClearedFlags */ 0,
        /*       Attributes */ ND_FLAG_NOREX2|ND_FLAG_MODRM,
        /*        CpuidFlag */ ND_CFF_RAOINT,
        /*         Operands */ 
        {
            OP(ND_OPT_M, ND_OPS_y, 0, ND_OPA_RW, 0, 0),
            OP(ND_OPT_G, ND_OPS_y, 0, ND_OPA_R, 0, 0),
        },
    }, 
    """
    idbe = instrux_to_idbe(ins)

    c = ''

    # Start with the position and encoding description.
    c += '    // Pos:%d Instruction:"%s" Encoding:"%s"/"%s"\n' % (
         ins.Icount,
         str(ins),
         ins.RawEnc,
         ''.join([x.Encoding for x in ins.ExpOps]).replace('S', ''))

    c += '    {\n'

    for field in idbe:
        if idbe_format_designated:
            c += '        .%s = ' % field
        else:
            c += '        /* %16s */ ' % field
        
        if type(idbe[field]) is list:
            c += '\n'
            c += '        {\n'
            if len(idbe[field]) == 0:
                c += '                0\n'
            else:
                for entry in idbe[field]:
                    c += '            ' + entry + ',\n'
            c += '        },\n'
        else:
            c += str(idbe[field]) + ',\n'

    c += '    }'

    return c


def dump_translation_tables(
    instructions: list[instrux.Instruction]
):
    """
    Generate the instruction translation trees.
    """
    table_legacy = []
    table_xop    = []
    table_vex    = []
    table_evex   = []

    group_legacy = {}
    group_vex    = {}
    group_xop    = {}
    group_evex   = {}
    
    # Distribute each instruction type into its own table.
    for i in instructions:
        if   i.Vex:  table_vex.append(i)
        elif i.Xop:  table_xop.append(i)
        elif i.Evex: table_evex.append(i)
        else:        table_legacy.append(i)

    #
    # Legacy map.
    #
    group_legacy = instrux_grouper.group_instructions(table_legacy, instrux_grouper.components_legacy)
    group_cdef = group_generate_c_table(group_legacy, 'gLegacyMap_%s' % group_legacy.Component.Type)

    print('Writing the bdx86_table_root.h file...')
    with open(r'../bddisasm/include/bdx86_table_root.h', 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_TABLE_ROOT_H\n')
        f.write('#define BDX86_TABLE_ROOT_H\n\n')
        f.write(group_cdef)
        f.write('\n#endif\n\n')


    #
    # VEX map.
    #
    group_vex = instrux_grouper.group_instructions(table_vex, instrux_grouper.components_ex)
    group_cdef = group_generate_c_table(group_vex, 'gVexMap_%s' % group_vex.Component.Type)

    print('Writing the bdx86_table_vex.h file...')
    with open(r'../bddisasm/include/bdx86_table_vex.h', 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_TABLE_VEX_H\n')
        f.write('#define BDX86_TABLE_VEX_H\n\n')
        f.write(group_cdef)
        f.write('\n#endif\n\n')


    #
    # XOP map.
    #
    group_xop = instrux_grouper.group_instructions(table_xop, instrux_grouper.components_ex)
    group_cdef = group_generate_c_table(group_xop, 'gXopMap_%s' % group_xop.Component.Type)

    print('Writing the bdx86_table_xop.h file...')
    with open(r'../bddisasm/include/bdx86_table_xop.h', 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_TABLE_XOP_H\n')
        f.write('#define BDX86_TABLE_XOP_H\n\n')
        f.write(group_cdef)
        f.write('\n#endif\n\n')


    #
    # EVEX map.
    #
    group_evex = instrux_grouper.group_instructions(table_evex, instrux_grouper.components_ex)
    group_cdef = group_generate_c_table(group_evex, 'gEvexMap_%s' % group_evex.Component.Type)

    print('Writing the bdx86_table_evex.h file...')
    with open(r'../bddisasm/include/bdx86_table_evex.h', 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_TABLE_EVEX_H\n')
        f.write('#define BDX86_TABLE_EVEX_H\n\n')
        f.write(group_cdef)
        f.write('\n#endif\n\n')


#
# This dictionary describes how the decoding tables look. Each decoding component has associated a C decoding table.
#
components_ilut = {
    'opcode' :      { 'ilut': 'ND_ILUT_OPCODE',         'type': 'ND_TABLE_OPCODE'     },
    'opcode_last' : { 'ilut': 'ND_ILUT_OPCODE_LAST',    'type': 'ND_TABLE_OPCODE'     },
    'modrmmod' :    { 'ilut': 'ND_ILUT_MODRM_MOD',      'type': 'ND_TABLE_MODRM_MOD'  },
    'modrmreg' :    { 'ilut': 'ND_ILUT_MODRM_REG',      'type': 'ND_TABLE_MODRM_REG'  },
    'modrmrm' :     { 'ilut': 'ND_ILUT_MODRM_RM',       'type': 'ND_TABLE_MODRM_RM'   },
    'prefix' :      { 'ilut': 'ND_ILUT_MAN_PREFIX',     'type': 'ND_TABLE_MPREFIX'    },
    'mode' :        { 'ilut': 'ND_ILUT_MODE',           'type': 'ND_TABLE_MODE'       },
    'dsize' :       { 'ilut': 'ND_ILUT_DSIZE',          'type': 'ND_TABLE_DSIZE'      },
    'asize' :       { 'ilut': 'ND_ILUT_ASIZE',          'type': 'ND_TABLE_ASIZE'      },
    'auxiliary' :   { 'ilut': 'ND_ILUT_AUXILIARY',      'type': 'ND_TABLE_AUXILIARY'  },
    'vendor' :      { 'ilut': 'ND_ILUT_VENDOR',         'type': 'ND_TABLE_VENDOR'     },
    'feature' :     { 'ilut': 'ND_ILUT_FEATURE',        'type': 'ND_TABLE_FEATURE'    },
    'mmmmm' :       { 'ilut': 'ND_ILUT_EX_M',           'type': 'ND_TABLE_EX_M'       },
    'pp' :          { 'ilut': 'ND_ILUT_EX_PP',          'type': 'ND_TABLE_EX_PP'      },
    'l' :           { 'ilut': 'ND_ILUT_EX_L',           'type': 'ND_TABLE_EX_L'       },
    'w' :           { 'ilut': 'ND_ILUT_EX_W',           'type': 'ND_TABLE_EX_W'       },
    'wi' :          { 'ilut': 'ND_ILUT_EX_WI',          'type': 'ND_TABLE_EX_W'       },
    'nd' :          { 'ilut': 'ND_ILUT_EX_ND',          'type': 'ND_TABLE_EX_ND'      },
    'nf' :          { 'ilut': 'ND_ILUT_EX_NF',          'type': 'ND_TABLE_EX_NF'      },
    'sc' :          { 'ilut': 'ND_ILUT_EX_SC',          'type': 'ND_TABLE_EX_SC'      },
    'lpdf' :        { 'ilut': 'ND_ILUT_EX_LPDF',        'type': 'ND_TABLE_EX_LPDF'    },
}


def group_generate_c_table(
    group: instrux_grouper.InstructionGroup, 
    name: str
) -> str:
    """
    Generate the translation tree, in C format, for the decoding tree identified by group.
    """
    if group.Component is not None:
        if group.Component.Type in components_ilut:
            comp_type = components_ilut[group.Component.Type]['type']
            comp_ilut = components_ilut[group.Component.Type]['ilut']
        elif group.Component.Filter:
            comp_type = 'ND_TABLE_FILTER'
            comp_ilut = 'ND_ILUT_FLT_' + group.Component.Type.upper()
        else:
            raise Exception("Unknwon group component: %s" % group.Component.Type)

        current_table = ''
        current_table += 'const %s %s = \n' % (comp_type, name)
        current_table += '{\n'
        current_table += '    %s,\n' % comp_ilut
        current_table += '    0,\n'
        current_table += '    {\n'
        for i in range(0, len(group.Children)):
            if not group.Children[i]:
                current_table += '        /* %02x */ (const void *)ND_NULL,\n' % (i)
            else:
                next_name = group.Children[i].Component.Type if group.Children[i].Component else 'leaf'
                current_name = name + ('_%02x_%s' % (i, next_name))
                current_table += '        /* %02x */ (const void *)&%s,\n' % (i, current_name)
                current_table = group_generate_c_table(group.Children[i], current_name) + current_table
        current_table += '    }\n'
        current_table += '};\n\n'
        return current_table
    else:
        # Instruction, construct a dummy table that directly points to the instruction.
        res  = 'const ND_TABLE_INSTRUCTION %s = \n' % name
        res += '{\n'
        res += '    ND_ILUT_INSTRUCTION,\n'
        res += '    %d, // %s\n' % (group.Children.Icount, str(group.Children))
        res += '    0,\n'
        res += '};\n\n'
        return res


def generate_mnemonics(instructions):
    mnemonics = []

    for i in instructions:
        mnemonics.append(i.Mnemonic)

    return sorted(set(mnemonics))

def generate_constants(lst, pre = False):
    constants = []

    for i in lst:
        if pre:
            constants.append('ND_PRE_' + i.Mnemonic)
        else:
            constants.append('ND_INS_' + i.Class)

    return sorted(set(constants))

def generate_constants2(instructions):
    constants_sets, constants_types = [], []

    for i in instructions:
        constants_sets.append('ND_SET_' + i.Set)
        constants_types.append('ND_CAT_' + i.Category)

    return sorted(set(constants_sets)), sorted(set(constants_types))

def generate_modrm(instructions):
    # 3-dimensional structure, where we index using:
    # - encoding mode (legacy, xop, vex, evex)
    # - map (0-31)
    # - opcode (0-255)
    modrm = {}

    for i in range(0, 4):
        # Encoding mode.
        modrm[i] = {}
        for j in range(0, 32):
            # Map ID.
            modrm[i][j] = []

    for i in instructions:
        if i.Xop:
            mod_idx, map_idx = 1, int(i.Encoding['mmmmm'][0], 16)
        elif i.Vex:
            mod_idx, map_idx = 2, int(i.Encoding['mmmmm'][0], 16) 
        elif i.Evex:
            mod_idx, map_idx = 3, int(i.Encoding['mmmmm'][0], 16)
        else:
            mod_idx = 0
            if len(i.Encoding['opcode']) == 1:
                map_idx = 0
            elif len(i.Encoding['opcode']) == 2:
                map_idx = 1
            elif i.Encoding['opcode'][1] == '0x38':
                map_idx = 2
            else:
                map_idx = 3
        
        if not modrm[mod_idx][map_idx]:
            modrm[mod_idx][map_idx] = [0] * 256

        if i.Attributes.contains('MODRM'):
            opc_idx = int(i.Encoding['opcode'][-1], 16)
            modrm[mod_idx][map_idx][opc_idx] = 1
            if i.Attributes.contains('MFR'):
                # Special case for CR and DR instructions, where mod is ignored.
                modrm[mod_idx][map_idx][opc_idx] = 2

    return modrm

def generate_rex2(instructions):
    # 2-dimensional structure, where we index using:
    # - map (0-1)
    # - opcode (0-255)
    # REX2 is only available for Legacy maps 0 & 1.
    rex2 = {}

    for i in range(0, 2):
        rex2[i] = [0] * 256

    for i in instructions:
        if i.Xop or i.Vex or i.Evex:
            continue

        if len(i.Encoding['opcode']) == 1:
            map_idx = 0
        elif len(i.Encoding['opcode']) == 2:
            map_idx = 1
        else:
            continue

        opc_idx = int(i.Encoding['opcode'][-1], 16)

        # If there is a group where some instructions support REX2 and some don't, we will mark the
        # entire group as supporting REX2. In that case, the decoding tree generator will automatically
        # add a filter for each of the instructions in the group that don't support REX2, filter that
        # will be checked during decoding.
        if not i.Attributes.contains('NOREX2'):
            rex2[map_idx][opc_idx] = 1

    return rex2

def dump_mnemonics(mnemonics, fname):
    with open(fname, 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_MNEMONICS_H\n')
        f.write('#define BDX86_MNEMONICS_H\n')
        f.write('\n')
        f.write('#ifndef BDDISASM_NO_MNEMONIC\n')
        f.write('\n')
        f.write('#define ND_MNEMONICS_COUNT %d\n' % len(mnemonics))
        f.write('\n')
        f.write('const char *gMnemonics[ND_MNEMONICS_COUNT] = \n')
        f.write('{\n')

        i = 0
        ln = 0
        for m in mnemonics:
            f.write('    "%s",\n' % m)

        f.write('\n};\n')

        f.write('\n')
        f.write('#endif // !BDDISASM_NO_MNEMONIC\n')

        f.write('\n\n')

        f.write('#endif\n\n')

def dump_constants(constants, constants_sets, constants_types, fname):
    with open(fname, 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_CONSTANTS_H\n')
        f.write('#define BDX86_CONSTANTS_H\n\n')
        f.write('\n')
        f.write('typedef enum _ND_INS_CLASS\n')
        f.write('{\n')
        f.write('    ND_INS_INVALID = 0,\n')

        for c in constants:
            f.write('    %s,\n' % c)

        f.write('\n} ND_INS_CLASS;\n\n\n')

        # Now the instruction sets.
        f.write('typedef enum _ND_INS_SET\n')
        f.write('{\n')
        f.write('    ND_SET_INVALID = 0,\n')
        for c in constants_sets:
            f.write('    %s,\n' % c)
        f.write('\n} ND_INS_SET;\n\n\n')
    
        # Now the instruction types.
        f.write('typedef enum _ND_INS_TYPE\n')
        f.write('{\n')
        f.write('    ND_CAT_INVALID = 0,\n')
        for c in constants_types:
            f.write('    %s,\n' % c)
        f.write('\n} ND_INS_CATEGORY;\n\n\n')
    
        # Done!
        f.write('\n#endif\n')

def dump_master_table(instructions, fname):
    with open(fname, 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_INSTRUCTIONS_H\n')
        f.write('#define BDX86_INSTRUCTIONS_H\n')
        f.write('\n')
        f.write('#define ND_INSTRUCTIONS_COUNT %d\n' % len(instructions))
        f.write('\n')
        flags = []
        f.write('const ND_IDBE gInstructions[ND_INSTRUCTIONS_COUNT] = \n')
        f.write('{\n')
        for i in instructions:
            f.write('%s, \n\n' % cdef_instruction(i))
        f.write('\n};\n')
        f.write('\n#endif\n')

def dump_features(features, fname):
    with open(fname, 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_CPUID_FLAGS_H\n')
        f.write('#define BDX86_CPUID_FLAGS_H\n')

        f.write('\n')
        f.write('#define ND_CFF_NO_LEAF    0xFFFFFFFF\n')
        f.write('#define ND_CFF_NO_SUBLEAF 0x00FFFFFF\n')
        f.write('\n')
        f.write('\n')
        f.write('#define ND_CFF(leaf, subleaf, reg, bit) ((ND_UINT64)(leaf) | ((ND_UINT64)((subleaf) & 0xFFFFFF) << 32) | ((ND_UINT64)(reg) << 56) | ((ND_UINT64)(bit) << 59))\n')

        for c in features:
            f.write('#define ND_CFF_%s%sND_CFF(%s, %s, %s, %s)\n' % (c.Name, ' ' * (25 - len(c.Name)), c.Leaf, c.SubLeaf, 'NDR_' + c.Reg, c.Bit))

        f.write('\n')

        f.write('#endif // BDX86_CPUID_FLAGS_H\n')

def dump_modrm(modrm, fname):
    with open(fname, 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_MODRM_H\n')
        f.write('#define BDX86_MODRM_H\n')
        f.write('\n')

        mode_name = {
            0: 'Legacy',
            1: 'Xop',
            2: 'Vex',
            3: 'Evex',
        }

        # Dump opcode tables.
        for mode in modrm:
            for map in modrm[mode]:
                if not modrm[mode][map]:
                    continue
                f.write(f'static const ND_UINT8 gModrmTable{mode_name[mode]}Map{map}[256] = \n')
                f.write('{\n')
                f.write('//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n')
                cnt = 0
                for opc in modrm[mode][map]:
                    if cnt % 16 == 0:
                        f.write('    ')
                    f.write('%d, ' % opc)
                    cnt = cnt + 1
                    if cnt % 16 == 0:
                        f.write('// %X\n' % (cnt // 16 - 1))
                f.write('};\n\n')

        # Dump map table.
        f.write(f'static const ND_UINT8 *gModrmTable[{len(modrm)}][{len(modrm[0])}] = \n')
        f.write('{\n')
        for mode in modrm:
            f.write('    {\n')
            for map in modrm[mode]:
                if not modrm[mode][map]:
                    f.write(f'        ND_NULL,\n')
                else:
                    f.write(f'        gModrmTable{mode_name[mode]}Map{map},\n')
            f.write('    },\n')
        f.write('};\n')

        f.write('\n')

        f.write('#endif // BDX86_MODRM_H\n')

def dump_rex2(rex2, fname):
    with open(fname, 'wt') as f:
        f.write(header)
        f.write('#ifndef BDX86_REX2_H\n')
        f.write('#define BDX86_REX2_H\n')
        f.write('\n')

        # Dump map table.
        f.write(f'static const ND_UINT8 gRex2Table[2][256] = \n')
        f.write('{\n')
        for map in rex2:
            f.write('    {\n')
            f.write('    //  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n')
            cnt = 0
            for opc in rex2[map]:
                if cnt % 16 == 0:
                    f.write('        ')
                f.write('%d, ' % opc)
                cnt = cnt + 1
                if cnt % 16 == 0:
                    f.write('// %X\n' % (cnt // 16 - 1))
            f.write('    },\n\n')
        f.write('};\n')

        f.write('\n')

        f.write('#endif // BDX86_REX2_H\n')

#
# =============================================================================
# Main
# =============================================================================
#
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print('Usage: %s defs-file-dir' % os.path.basename(sys.argv[0]))
        sys.exit(-1)

    # Extract the CPUID features.
    print('Loading CPUID feature flags...')
    features = disasmlib.parse_cff_file(f'{sys.argv[1]}/cpuid.dat')

    # Extract the instructions.
    for fn in glob.glob(f'{sys.argv[1]}/table*.dat'):
        print('Loading instructions from %s...' % os.path.basename(fn))
        instructions = instructions + disasmlib.parse_ins_file(fn)

    # Sort the instructions.
    instructions = sorted(instructions, key = lambda x: x.Mnemonic)
    for i in range(0, len(instructions)):
        instructions[i].Icount = i

    # Generate the mnemonics
    mnemonics = generate_mnemonics(instructions)

    # Generate the constants
    constants = generate_constants(instructions)
    constants_sets, constants_types = generate_constants2(instructions)

    # Generate the ModRM table.
    modrm = generate_modrm(instructions)

    # Generate the REX2 table.
    rex2 = generate_rex2(instructions)


    #
    # Dump all data to files.
    #

    # Dump the mnemonics
    print('Writing the bdx86_mnemonics.h (instruction mnemonics) file...')
    dump_mnemonics(mnemonics, r'../bddisasm/include/bdx86_mnemonics.h')

    # Dump the instruction constants
    print('Writing the bdx86_constants.h (instruction definitions) file...')
    dump_constants(constants, constants_sets, constants_types, r'../inc/bdx86_constants.h')

    # Dump the CPUID feature flags.
    print('Writing the bdx86_cpuidflags.h (CPUID feature flags) file...')
    dump_features(features, r'../inc/bdx86_cpuidflags.h')

    # Dump the ModRm table.
    print('Writing the bdx86_modrm.h file...')
    dump_modrm(modrm, r'../bddisasm/include/bdx86_modrm.h')

    # Dump the REX2 table.
    print('Writing the bdx86_rex2.h file...')
    dump_rex2(rex2, r'../bddisasm/include/bdx86_rex2.h')

    # Dump the instruction database.
    print('Writing the bdx86_instructions.h (main instruction database) file...')
    dump_master_table(instructions, r'../bddisasm/include/bdx86_instructions.h')

    # Dump the translation tables.
    print('Writing the translation tables...')
    dump_translation_tables(instructions)

    print('Instruction successfully parsed & header files generated!')
